---
layout: post
title:  "缓存锁"
date:   2016-04-13 20:54:11
categories: jekyll update
---
今天跟同事一起发明了一种新技术——缓存锁（因为是把缓存当锁用，姑且命名“缓存锁”）。
之所以要使用锁，是因为分布式的机器各自拥有内存，他们内存中的数据一致性无法保证，大部分场景下并不需要保证不同的机器中内存的一致性，但某些场景下却是需要的。

我们碰到的问题是这样的，我们需要在一个团购发布时，把里面包含的图片同步一份到商户下。通过接收消息来知道一个团购发布。同时要保证一张图片同步到一个商户下只一次。这一点，只需要写之前查一下历史数据，已有的数据不再同步。

但是，问题并没有结束。存在这样的情况，若干个包含相同内容的团购同时发布（假定2个），他们是不同的消息，到达我们集群的负载均衡时，被几乎同时发到两台机器上。两个操作几乎同步的去查历史数据，发现没有，然后都自己向数据库写一条记录。于是就重复了。

仔细想一下这个问题，其实我们本质是要保证一个shopId-url的唯一性。

这个唯一性其实数据库本身有这样的机制（唯一性键？），但是我们的表历史悠久，数据量大，更换表结构成本较大。

于是就只能想办法在靠前的程序中去保证。此时，馒头提了一个建议，在写之前增加一个缓存，方法是，来一个记录，先去写shopId-url到ip的k-v对，然后查历史去重，然后再读缓存，如果shopid-url的v是自己的ip，就说明是自己写的，可以在DB增加一条记录；否则，说明别人也想写，然后自己就不向DB增加记录。

经过我的思考，发现有一个更简单的办法，只写一次，如果key已存在，则说明在自己之前有人准备写库，那么自己就不写库，否则，把k-v写进去，从而告诉别人我要写，后面的人不用写了。

然后把一个缓存的生存时间设置为一次接口操作全部完成所需时间的稍大一点的时间，10s。这就相当于自己持有了这个锁10s种，之后这个锁被释放。此后的唯一性就可以由查历史数据来完成了。

问题完美解决。
