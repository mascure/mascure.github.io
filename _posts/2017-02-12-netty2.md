---
layout: post
title:  "《Netty权威指南》读书笔记-2"
date:   2017-02-12 22:46:41
categories: jekyll update
---
#### 处理粘包/拆包问题，编解码 ####
##### 粘包/拆包问题的由来 #####
![tcp_package](/assets/images/TCP_Package.jpeg)

假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。  
（1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；  
（2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；  
（3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；  
（4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。  
如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。  

##### 粘包/拆包问题解决策略 #####
由于TCP无法理解上层的业务数据，所以底层无法保证数据包不被拆分和重组，这个问题只能通过上层的应用协议来解决。目前主要采用以下4中方式：  
（1）消息长度固定，累计读取到长度总和为定长LEN的报文后，就认为读取到了一个完整的消息；将计数器置位，重新开始读取下一个数据报；  
（2）将回车换行符作为消息结束符，例如FTP协议，这种方式在文本协议中应用比较广泛；  
（3）将特殊的分隔符作为消息的结束标志，回车换行符就是一种特殊的结束分隔符；  
（4）通过在消息头中定义长度字段来标识消息的总长度。  
Netty对上面四种应用做了统一的抽象，提供了4种解码器来解决对应的问题，使用起来非常方便。有了这些解码器，用户不需要自己对读取的报文进行人工解码，也不需要考虑TCP的粘包和拆包。  

##### 编解码 #####
编码是指将java对象转换成字节数组传输到网络上，解码正好相反。这一技术也可以叫做序列化技术。

由于java自带的序列化技术太烂（无法跨语言，体积大，性能差），目前主流的编解码技术如下：  
1、Google的Protobuf；  
2、Facebook的Thrift；  
3、JBoss Marshalling。
目前点评的pigeon一般采用hessian。

#### 内存池原理 ####
为了提高分配和释放内存时候的性能，netty接管了缓冲区的内存管理：预先申请一大块内存，并提供相应的分配和释放接口来使用内存。由于不再频繁使用系统调用来申请和释放内存，性能也会大大提高。

注意，Netty的缓冲区使用的是堆外直接内存，并不是jvm虚拟机管理的内存。这种做法的好处是“零拷贝”，使用堆外直接内存进行socket读写；如果使用堆内存，则jvm会将堆内存拷贝一份到直接内存，然后再写入socket。

Netty的内存池是由多个Chunk组成的大块内存区域，每个Chunk的数据结构如下图所示：

![chunk](/assets/images/chunk.jpeg)
树中的每个节点都可以通过状态为来标识该块内存是否可用，看到这个图应该知道如何分配和释放了:)

#### 线程模型 ####
##### Reactor单线程模型 #####
所有的IO操作都在同一个NIO线程上面完成，职责包括：  
作为NIO服务端，接收客户端的TCP连接；  
作为NIO客户端，向服务端发起TCP连接；  
读取通信对端的请求或者应答消息；  
向通信对端发送消息请求或者应答消息。

![reactor_single](/assets/images/reactor_single.jpeg)

对于高负载，大并发的应用，单线程无法满足海量消息的编码，解码，读取和发送。

##### 多线程模型 #####
由一组NIO线程来处理IO操作。

![reactor_multi](/assets/images/reactor_multi.jpeg)

特点如下：  
有专门一个NIO线程——Acceptor线程用于监听服务端，接收客户端的TCP连接请求。  
网络I/O操作——读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送。  
一个NIO线程可以同时处理N条链路，但是一个链路只对应一个NIO线程，防止发生并发操作问题。

对于并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足的问题，为了解决性能问题，产生了第三种Reactor线程模型——主从Reactor多线程模型。

##### 主从Reactor多线程模型 #####
该模型实质上是将Acceptor线程替换为Acceptor线程池，负责客户端的连接，登陆，握手和安全认证。一旦链路建立成功，就将链路注册到后端的subReactor线程池的IO线程上，由IO线程负责后续的IO操作。

![reactor_master_slave](/assets/images/reactor_master_slave.jpeg)

Netty的官方demo中，推荐使用该线程模型。

#### volatile 锁的使用经验 ####
根据经验总结，volatile最适合使用的是一个线程写，其他线程读的场合。如果有多个线程并发写操作，仍然需要使用锁或者线程安全的容器或原子变量来代替。
