<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
昨天某厂面试，问到Linux中锁的用法，于是回来巩固（学习）了一下。
使用锁除了保证进程（线程）间对变量的互斥访问外，还可以达到进程（线程）同步。

Linux中有自旋锁，信号量，互斥量三种锁，互斥量只能用于线程间，讲解见[这里]，信号量可以用于进程间，也可以用于线程间，[进程间用法]，[线程间用法]。[自旋锁用法]。

[这里]:http://blog.csdn.net/ljianhui/article/details/10875883
[进程间用法]:http://blog.csdn.net/ljianhui/article/details/10243617
[线程间用法]:http://blog.csdn.net/ljianhui/article/details/10813469
[自旋锁用法]:http://www.cnblogs.com/biyeymyhjob/archive/2012/07/21/2602015.html

线程间同步：

互斥量：

~~~~{c++}
#include <pthread.h>  

int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);

int pthread_mutex_lock(pthread_mutex_t *mutex);

int pthread_mutex_unlock(pthread_mutex_t *mutex);

int pthread_mutex_destroy(pthread_mutex_t *mutex);
~~~~
用法：
使用init初始化一个mutex，然后lock与unlock之间，可以获得这个锁，其他想获得这个锁的线程会挂起。结束的时候destroy。下面是一个控制主线程和子线程交替执行的例子。

~~~~{c++}
pthread_mutex_t mutex;

int main(){
    ...
    res = pthread_mutex_init(&mutex, NULL);
res = pthread_create(&thread, NULL, thread_func, msg);
lock(mutex);
while(condition){
    ...
    unlock();
    sleep(1);
    lock();
}
}

void* thread_func(void *msg){
lock();
while(condition){
    ...
    unlock();
    sleep(1);
    lock();
}
}

~~~~

使用信号量控制主线程和子线程交替执行的例子。

~~~~{c++}
//声明信号量
sem_t sem1,sem2;

int main{
//初始化信号量
res = sem_init(&sem1, 0, 0);
res = sem_init(&sem2, 0, 1);
res = pthread_create(&thread, NULL, thread_func, msg);
sem_wait(&sem2);
while(condition){
...
sem_post(&sem1);
sem_wait(&sem2);
}
}

void* thread_func(void *msg){
sem_wait(&sem1);
while(condition){
...
sem_post(sem2);
sem_wait(sem1);
}
sem_post(sem2);
}
~~~~

<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>昨天某厂面试，问到Linux中锁的用法，于是回来巩固（学习）了一下。
使用锁除了保证进程（线程）间对变量的互斥访问外，还可以达到进程（线程）同步。</p>

<p>Linux中有自旋锁，信号量，互斥量三种锁，互斥量只能用于线程间，讲解见<a href="http://blog.csdn.net/ljianhui/article/details/10875883">这里</a>，信号量可以用于进程间，也可以用于线程间，<a href="http://blog.csdn.net/ljianhui/article/details/10243617">进程间用法</a>，<a href="http://blog.csdn.net/ljianhui/article/details/10813469">线程间用法</a>。<a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/21/2602015.html">自旋锁用法</a>。</p>

<p>线程间同步：</p>

<p>互斥量：</p>

<pre class=" language-c"><code class="++ language-c"><span class="token property">#include <span class="token property">&lt;pthread.h&gt;</span>  </span>

<span class="token keyword">int</span> <span class="token function">pthread_mutex_init<span class="token punctuation">(</span></span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_mutexattr_t <span class="token operator">*</span>mutexattr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">pthread_mutex_lock<span class="token punctuation">(</span></span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock<span class="token punctuation">(</span></span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy<span class="token punctuation">(</span></span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>用法：
使用init初始化一个mutex，然后lock与unlock之间，可以获得这个锁，其他想获得这个锁的线程会挂起。结束的时候destroy。下面是一个控制主线程和子线程交替执行的例子。

<pre class=" language-c"><code class="++ language-c">pthread_mutex_t mutex<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    res <span class="token operator">=</span> <span class="token function">pthread_mutex_init<span class="token punctuation">(</span></span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>
res <span class="token operator">=</span> <span class="token function">pthread_create<span class="token punctuation">(</span></span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span> NULL<span class="token punctuation">,</span> thread_func<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">lock<span class="token punctuation">(</span></span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">unlock<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">lock<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">thread_func<span class="token punctuation">(</span></span><span class="token keyword">void</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">lock<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">unlock<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">lock<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>

<p>使用信号量控制主线程和子线程交替执行的例子。</p>

<pre class=" language-c"><code class="++ language-c"><span class="token comment" spellcheck="true">//声明信号量
</span>sem_t sem1<span class="token punctuation">,</span>sem2<span class="token punctuation">;</span>

<span class="token keyword">int</span> main<span class="token punctuation">{</span><span class="token comment" spellcheck="true">
//初始化信号量
</span>res <span class="token operator">=</span> <span class="token function">sem_init<span class="token punctuation">(</span></span><span class="token operator">&amp;</span>sem1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
res <span class="token operator">=</span> <span class="token function">sem_init<span class="token punctuation">(</span></span><span class="token operator">&amp;</span>sem2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
res <span class="token operator">=</span> <span class="token function">pthread_create<span class="token punctuation">(</span></span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span> NULL<span class="token punctuation">,</span> thread_func<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sem_wait<span class="token punctuation">(</span></span><span class="token operator">&amp;</span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">sem_post<span class="token punctuation">(</span></span><span class="token operator">&amp;</span>sem1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sem_wait<span class="token punctuation">(</span></span><span class="token operator">&amp;</span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">thread_func<span class="token punctuation">(</span></span><span class="token keyword">void</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">sem_wait<span class="token punctuation">(</span></span><span class="token operator">&amp;</span>sem1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">sem_post<span class="token punctuation">(</span></span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sem_wait<span class="token punctuation">(</span></span>sem1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">sem_post<span class="token punctuation">(</span></span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "lock-in-linux.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
